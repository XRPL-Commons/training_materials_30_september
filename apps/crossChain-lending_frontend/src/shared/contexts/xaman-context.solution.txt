import { FC, ReactNode, createContext, useCallback, useContext, useState } from 'react'
import { Payment, convertStringToHex, xrpToDrops } from 'xrpl'
import { Xumm } from 'xumm'
export type XamanContextApi = {
  isConnected: boolean
  account: string | null
  xummClient: Xumm | null
  connectXaman: () => Promise<void>
  disconnect: () => void
  bridgeToEVM: (amount: string, evmAddress: string) => Promise<string | null>
}

const XamanContext = createContext<XamanContextApi | null>(null)

type Props = {
  children: ReactNode
}

export const XamanProvider: FC<Props> = ({ children }) => {
  const [isConnected, setIsConnected] = useState(false)
  const [account, setAccount] = useState<string | null>(null)

  // Initialize Xumm client once
  const xumm = new Xumm(
    '15ba80a8-cba2-4789-a45b-c6a850d9d91b',
    '71bf1333-9c41-4979-8713-0d7f667395ce'
  )

  const connectXaman = useCallback(async () => {
    try {
      // Step 1 - Sign in with Xaman
      await xumm.authorize()

      // Step 2 - Get authorized user and set state
      const authorizedUser = await xumm.user.account

      if (authorizedUser) {
        setAccount(authorizedUser)
        setIsConnected(true)
      } else {
        throw new Error('Failed to authorize with Xaman')
      }
    } catch (error) {
      console.error('Error connecting to Xaman:', error)
      disconnect()
    }
  }, [xumm])

  const disconnect = useCallback(() => {
    setIsConnected(false)
    setAccount(null)
  }, [])

  const bridgeToEVM = useCallback(
    async (amount: string, evmAddress: string): Promise<string | null> => {
      if (!account) {
        throw new Error('Xaman not connected')
      }

      try {
        // Step 1 - Create the payment transaction for Axelar bridge
        const paymentTx: Payment = {
          TransactionType: 'Payment',
          Account: account,
          Destination: 'rNrjh1KGZk2jBR3wPfAQnoidtFFYQKbQn2', // Testnet relayer
          Amount: xrpToDrops(amount),
          Memos: [
            {
              Memo: {
                MemoType: convertStringToHex('type'),
                MemoData: convertStringToHex('interchain_transfer'),
              },
            },
            {
              Memo: {
                MemoType: convertStringToHex('destination_address'),
                MemoData: convertStringToHex(evmAddress.slice(2)),
              },
            },
            {
              Memo: {
                MemoType: convertStringToHex('destination_chain'),
                MemoData: convertStringToHex('xrpl-evm'),
              },
            },
            {
              Memo: {
                MemoType: convertStringToHex('gas_fee_amount'),
                MemoData: convertStringToHex('1700000'),
              },
            },
          ],
        }

        // Step 2 - Submit transaction via Xaman
        const payload = await xumm.payload.create({
          txjson: paymentTx,
          options: {
            force_network: 'TESTNET',
          },
          custom_meta: {
            identifier: `bridge-${Date.now()}`,
            instruction: `Bridge ${amount} XRP from XRPL to EVM address ${evmAddress}`,
          },
        })

        if (payload.uuid && payload.next?.always) {
          // Step 3 - Open Xaman for user approval
          window.open(payload.next.always, '_blank')

          // Step 4 - Wait for user to sign transaction
          const result = await xumm.payload.subscribe(payload.uuid)

          // Step 5 - Return transaction ID if signed, null if cancelled
          if (result.signed) {
            return result.txid || null
          } else {
            return null
          }
        } else {
          throw new Error('Failed to create payment payload')
        }
      } catch (error) {
        console.error('Error bridging to EVM:', error)
        throw error
      }
    },
    [xumm, account]
  )

  const value: XamanContextApi = {
    isConnected,
    account,
    xummClient: xumm,
    connectXaman,
    disconnect,
    bridgeToEVM,
  }

  return <XamanContext.Provider value={value}>{children}</XamanContext.Provider>
}

export const useXaman = () => {
  const context = useContext(XamanContext)
  if (!context) {
    throw new Error('useXaman must be used inside XamanProvider')
  }
  return context
}
